1.  A Literal is a constant variable whose value does not change during the lifetime of the program. 
    Whereas, a raw string literal is a string in which the escape characters like ‘ \n, \t, or \” ‘ 
    of C++ are not processed. Hence, a raw string literal that starts with R”( and ends in )”.
2.  Create a map to store unique substrings of size 2
    
    map<pair<char,char>, int> dPairs;
    string str("rajeshkjemara");
    
    // Count occurrences of all pairs
    for (int i=0; i<str.size()-1; i++)
        dPairs[make_pair(str[i], str[i+1])]++;
 
    // Traverse map to print sub-strings and their counts.
    for (auto it=dPairs.begin(); it!=dPairs.end(); it++)
        cout << it->first.first << it->first.second
             << "-" << it->second << " ";
3.  Following are the properties which a derived class doesn’t inherit from its parent class : 
    1) The base class’s constructors and destructor. 
    2) The base class’s friend functions.
    3) Overloaded operators of the base class.

4.  Object Slicing:
    When a derived class object is assigned to a base class object in C++, the derived class 
    object’s extra attributes are sliced off (not considered) to generate the base class object; 
    and this whole process is termed object slicing. In simple words, when extra components 
    of a derived class are sliced or not used and the priority is given to the base class’s object 
    this is termed object slicing.
    In C++, a derived class object can be assigned to a base class object, but the other way is not 
    possible. To tackle this slicing problem we can use a dynamic pointer.
    Derived class object sliced from memory allocation.
    We can avoid the above-unexpected behavior with the use of pointers or references. 
    Object slicing doesn’t occur when pointers or references to objects are passed as function arguments 
    since a pointer or reference of any type takes the same amount of memory.
    Object slicing can be prevented by making the base class function pure virtual thereby disallowing 
    object creation. It is not possible to create the object of a class that contains a pure virtual 
    method.
5.  Hiding of all Overloaded:
    In C++, function overloading is possible i.e., two or more functions from the same class 
    can have the same name but different parameters. However, if a derived class redefines the 
    base class member method then all the base class methods with the same name become hidden in 
    the derived class.
    Even if the signature of the derived class method is different, all the overloaded methods in 
    the base class become hidden.
    The above facts are true for both static and non static methods.
    it is possible to unhide it by using the ‘using’ keyword. This keyword brings a base class 
    method ​or variable into the current class’s scope.
6.  Friendship in C++: Usually, private and protected members of a class cannot be accessed from outside
    the same class in which they are declared. However, a friend class has the access to the protected 
    and private members of the first one. Classes that are ‘friends’ can access not just the public 
    members, but the private and protected members too.
    Difference between Inheritance and Friendship in C++: In C++, friendship is not inherited. 
    If a base class has a friend function, then the function doesn’t become a friend of the derived 
    class(es).
    